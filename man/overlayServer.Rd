% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/server.R
\name{overlayServer}
\alias{overlayServer}
\title{Add interactive overlays to a Shiny plot}
\usage{
overlayServer(
  outputId,
  nrect,
  width = NULL,
  snap = "none",
  colours = overlayColours,
  opacity = 0.25,
  icon = shiny::icon("gear"),
  stagger = 0.045,
  debug = FALSE
)
}
\arguments{
\item{outputId}{The ID of the plot output (as used in \code{\link[=overlayPlotOutput]{overlayPlotOutput()}}).}

\item{nrect}{Number of overlay rectangles to support.}

\item{width}{Optional default overlay width in plot coordinates. If \code{NULL}
(default), set to 10\% of the plot width.}

\item{snap}{Function to "snap" overlay coordinates to a grid, or \code{"none"}
(default) for no snapping. See details for how to specify the snap
function.}

\item{colours}{A function to assign custom colours to the overlays. Should
be a function that takes a single integer (the number of overlays) and
returns colours in hexadecimal notation (e.g. "#FF0000"). Do not provide
opacity here as a fourth channel; use the \code{opacity} argument instead.}

\item{opacity}{Numeric value (0 to 1) indicating overlay transparency.}

\item{icon}{A Shiny icon to show the dropdown menu.}

\item{stagger}{Vertical offset between stacked overlays, as a proportion of
height.}

\item{debug}{If \code{TRUE}, prints changes to input values to the console for
debugging purposes.}
}
\value{
A \code{\link[shiny:reactiveValues]{shiny::reactiveValues()}} object with the following named fields:
\describe{
\item{n}{Number of overlays.}
\item{active}{Logical vector of length \code{n}; indicates which overlays are active.}
\item{show}{Logical; controls whether overlays are visible.}
\item{editing}{Index of the overlay currently being edited via the
dropdown menu (if any; \code{NA} otherwise).}
\item{last}{Index of the most recently added overlay.}
\item{snap}{Coordinate snapping function.}
\item{px, pw}{Overlay x-position and width in pixels.}
\item{py, ph}{Overlay y-position and height in pixels.}
\item{cx0, cx1}{Overlay x-bounds in plot coordinates.}
\item{label}{Character vector of labels shown at the top of each overlay.}
\item{outputId}{The output ID of the plot display area.}
\item{bound_cx, bound_cw}{x-position and width of the bounding area in plot coordinates.}
\item{bound_px, bound_pw}{x-position and width of the bounding area in pixels.}
\item{stagger}{Amount of vertical staggering (as proportion of height).}
\item{update_cx(i)}{Function to update \code{cx0}/\code{cx1} from \code{px}/\code{pw} for overlay \code{i}.}
\item{update_px()}{Function to update \code{px}/\code{pw} from \code{cx0}/\code{cx1} for all overlays.}
}
}
\description{
This function sets up server-side infrastructure to support draggable and
resizable overlays on a plot. This may be useful in applications where users
need to define ranges, regions of interest, or intervals for further input
or processing. Currently, the overlays are only designed to move along the
x axis of the plot.
}
\details{
Call this function once from your server code to initialise a set of overlay
rectangles for a specific plot. It creates reactive handlers for move,
resize, and dropdown menu actions, and allows adding new overlays by
dragging an \code{\link[=overlayToken]{overlayToken()}} onto the plot.

This function also defines a dynamic output UI slot with ID
\code{paste0(outputId, "_menu")}, which can be rendered using \code{\link[shiny:renderUI]{shiny::renderUI()}}.
When a user clicks the overlay's dropdown icon, this menu becomes visible
and can be populated with inputs for editing overlay-specific settings, e.g.
labels or numeric parameters tied to that overlay.

If you provide a coordinate snapping function (\code{snap} argument), it should
have the signature \verb{function(ov, i)} where \code{ov} is the
\code{\link[shiny:reactiveValues]{shiny::reactiveValues()}} object defining the overlays and their settings,
and \code{i} is the set of indices for the rectangles to be updated. The
intention is that you should change the values of \code{ov$cx0[i]} and
\code{ov$cx1[i]}; the pixel coordinates of the overlays will then be updated
automatically after the snapping function returns. You should make sure that
all \code{ov$cx0[i]} and \code{ov$cx1[i]} are within the coordinate bounds defined by
the plot, i.e. constrained by \code{ov$bound_cx} and \code{ov$bound_cw}, when the
function returns. This means, for example, if you are "rounding down"
\code{ov$cx0[i]} to some nearest multiple of a number, you should make sure it
doesn't become less than \code{ov$bound_cx}. Finally, the snapping function will
get triggered when the x axis range of the plot changes, so it may be a good
idea to provide one if the user might place an overlay onto the plot, but
then change the x axis range of the plot such that the overlay is no longer
visible. You can detect this by verifying whether the overlay rectangles are
"out of bounds" at the top of your snapping function. See example below.
}
\examples{
\dontrun{
server <- function(input, output) {
    ov <- overlayServer("my_plot", 4)
    ov$label <- LETTERS[1:4]

    output$my_plot_menu <- renderUI({
        i <- req(ov$editing)
        textInput("label_input", "Overlay label", value = ov$label[i])
    })

    observeEvent(input$label_input, {
        i <- req(ov$editing)
        ov$label[i] <- input$label_input
    })
}

# Example of a valid snapping function: snap to nearest round number and
# make sure the overlay is at least 10 units wide.
mysnap <- function(ov, i) {
    # remove any "out of bounds" overlays
    oob <- seq_len(ov$n) \%in\% i &
        (ov$cx0 < ov$bound_cx | ov$cx1 > ov$bound_cx + ov$bound_cw)
    ov$active[oob] <- FALSE

    # adjust position and with
    widths <- pmax(10, round(ov$cx1[i] - ov$cx0[i]))
    ov$cx0[i] <- pmax(round(ov$bound_cx),
        pmin(round(ov$bound_cx + ov$bound_cw) - widths, round(ov$cx0[i])))
    ov$cx1[i] <- pmin(round(ov$bound_cx + ov$bound_cw), ov$cx0[i] + widths)
}
}

}
\seealso{
\code{\link[=overlayPlotOutput]{overlayPlotOutput()}}, \code{\link[=overlayBounds]{overlayBounds()}}
}
